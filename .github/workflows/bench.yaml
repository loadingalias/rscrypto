name: Benchmark

on:
  schedule:
    # Run every other Sunday at 4AM UTC (1st and 15th for bi-weekly pattern)
    - cron: "0 4 1,15 * *"

  # Manual trigger with options
  workflow_dispatch:
    inputs:
      tune_only:
        description: "Run tuning only (skip benchmarks)"
        required: false
        type: boolean
        default: false

      crates:
        description: "Crate(s) to benchmark (comma-separated, leave empty for all)"
        required: false
        type: string
        default: ""

      run_linux_x64:
        description: "Run on Linux x86-64"
        required: false
        type: boolean
        default: true

      run_linux_arm64:
        description: "Run on Linux ARM64"
        required: false
        type: boolean
        default: false

      run_windows_x64:
        description: "Run on Windows x86-64"
        required: false
        type: boolean
        default: false

      specific_benches:
        description: "Specific benchmark binary names (optional, comma-separated)"
        required: false
        type: string
        default: ""

      run_crc64_tune:
        description: "Run fast crc64-tune (recommended exports; uploads logs)"
        required: false
        type: boolean
        default: false

      crc64_tune_quick:
        description: "Use --quick for crc64-tune (faster, noisier)"
        required: false
        type: boolean
        default: true

      run_tune_discovery:
        description: "Run CRC64 tuning discovery (threshold/stream optimization)"
        required: false
        type: boolean
        default: false

      regression_baseline:
        description: "Git ref for regression comparison (e.g., main, v1.0.0)"
        required: false
        type: string
        default: ""

env:
  RUST_BACKTRACE: 1
  CARGO_TERM_COLOR: always
  RSCRYPTO_BENCH_MODE: ci
  CARGO_INCREMENTAL: 0

# Lock down permissions to read-only by default
permissions:
  contents: read # Required for actions/checkout

jobs:
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Benchmark Execution - High-performance dedicated runners
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # For scheduled runs: only bench affected crates (cargo-rail change detection)
  # For manual runs: always run (user controls scope via inputs)
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  benchmark:
    name: Benchmark (${{ matrix.target.name }})
    if: github.event_name == 'schedule' || github.event.inputs.tune_only != 'true'
    runs-on: ${{ matrix.target.runner }}
    strategy:
      fail-fast: false
      matrix:
        target:
          # Linux x86-64 (Namespace)
          - name: x86_64-unknown-linux-gnu
            runner: namespace-profile-rscrypto-linux-x86
            platform-id: linux-x64

          # Linux ARM64 (Namespace)
          - name: aarch64-unknown-linux-gnu
            runner: namespace-profile-rscrypto-linux-arm64
            platform-id: linux-arm64

          # Windows x86-64 (GitHub free runner)
          - name: x86_64-pc-windows-msvc
            runner: windows-latest
            platform-id: windows-x64

    steps:
      # Check if this platform should run (for manual triggers)
      - name: Check Platform Selection
        id: should-run
        shell: bash
        run: |
          # For scheduled runs, always run all platforms
          if [ "${{ github.event_name }}" == "schedule" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            echo "Scheduled run - running all platforms"
            exit 0
          fi

          # For manual triggers, check platform-specific flags
          PLATFORM="${{ matrix.target.platform-id }}"

          case "$PLATFORM" in
            "linux-x64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_LINUX_X64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Linux x86-64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Linux x86-64 disabled - skipping"
              fi
              ;;
            "linux-arm64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_LINUX_ARM64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Linux ARM64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Linux ARM64 disabled - skipping"
              fi
              ;;
            "windows-x64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_WINDOWS_X64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Windows x86-64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Windows x86-64 disabled - skipping"
              fi
              ;;
            *)
              echo "enabled=false" >> "$GITHUB_OUTPUT"
              echo "Unknown platform - skipping"
              ;;
          esac
        env:
          GITHUB_EVENT_INPUTS_RUN_LINUX_X64: ${{ github.event.inputs.run_linux_x64 }}
          GITHUB_EVENT_INPUTS_RUN_LINUX_ARM64: ${{ github.event.inputs.run_linux_arm64 }}
          GITHUB_EVENT_INPUTS_RUN_WINDOWS_X64: ${{ github.event.inputs.run_windows_x64 }}

      - name: Checkout
        if: steps.should-run.outputs.enabled == 'true'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0 # Required for cargo rail affected (needs git history)

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # Setup: Rust toolchain, performance tools, and caching
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      # Install Rust toolchain (reads version from rust-toolchain.toml)
      - name: Read Toolchain Version
        if: steps.should-run.outputs.enabled == 'true'
        id: toolchain
        shell: bash
        run: |
          TOOLCHAIN=$(awk -F'"' '/^channel/ {print $2}' rust-toolchain.toml)
          echo "version=$TOOLCHAIN" >> "$GITHUB_OUTPUT"

      - name: Install Rust Toolchain
        if: steps.should-run.outputs.enabled == 'true'
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # master
        with:
          toolchain: ${{ steps.toolchain.outputs.version }}
          components: clippy, rustfmt

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # Caching Strategy:
      # - Linux (Namespace runners): Namespace NVMe cache
      # - Windows (GitHub larger + Namespace): rust-cache with GitHub backend
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      - name: Setup Namespace Cache (Linux - instant NVMe cache)
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Linux'
        uses: namespacelabs/nscloud-cache-action@446d8f390563cd54ca27e8de5bdb816f63c0b706 # v1.2.21
        with:
          cache: rust

      # Compute cache key from runner metadata
      - name: Compute Cache Key
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Windows'
        id: cache
        shell: bash
        run: |
          OS=$(echo "${{ runner.os }}" | tr '[:upper:]' '[:lower:]')
          ARCH=$(echo "${{ runner.arch }}" | tr '[:upper:]' '[:lower:]')
          echo "key=bench-${OS}-${ARCH}" >> "$GITHUB_OUTPUT"

      - name: Setup Rust Cache (Windows)
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Windows'
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2.8.2
        with:
          shared-key: "rscrypto-v1"
          key: ${{ steps.cache.outputs.key }}
          cache-on-failure: true

      - name: Install Benchmarking Tools
        if: steps.should-run.outputs.enabled == 'true'
        uses: taiki-e/install-action@de7896b7cd1c7d181266425abbe571b5a8c757bc # v2.65.3
        with:
          tool: cargo-criterion,critcmp,just

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # Run Benchmarks
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      # Install cargo-rail for scheduled runs (change detection)
      - name: Install cargo-rail (Scheduled runs only)
        if: steps.should-run.outputs.enabled == 'true' && github.event_name == 'schedule'
        uses: taiki-e/install-action@de7896b7cd1c7d181266425abbe571b5a8c757bc # v2.65.3
        with:
          tool: cargo-rail

      - name: Determine Benchmark Scope
        if: steps.should-run.outputs.enabled == 'true'
        id: scope
        shell: bash
        run: |
          CRATES_INPUT="${GITHUB_EVENT_INPUTS_CRATES}"
          BENCHES_INPUT="${GITHUB_EVENT_INPUTS_SPECIFIC_BENCHES}"
          EVENT_NAME="${GITHUB_EVENT_NAME}"

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Determining Benchmark Scope"
          echo "Event: $EVENT_NAME"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # ─────────────────────────────────────────────────────────
          # SCHEDULED RUNS: Use cargo-rail change detection
          # ─────────────────────────────────────────────────────────
          if [ "$EVENT_NAME" == "schedule" ]; then
            echo "Scheduled run - using cargo-rail change detection"

            # Get affected crates since ~2 weeks of commits
            AFFECTED=$(cargo rail affected --since HEAD~50 -f names-only 2>/dev/null || echo "")

            if [ -z "$AFFECTED" ]; then
              echo "No crates changed in last ~2 weeks, running full workspace"
              echo "crate_flags=--workspace" >> "$GITHUB_OUTPUT"
              echo "skip_bench=false" >> "$GITHUB_OUTPUT"
            else
              # Build -p flags for each affected crate
              CRATE_FLAGS=""
              CRATE_LIST=""
              while IFS= read -r crate; do
                if [ -n "$crate" ]; then
                  CRATE_FLAGS="$CRATE_FLAGS -p $crate"
                  CRATE_LIST="$CRATE_LIST $crate"
                fi
              done <<< "$AFFECTED"

              if [ -n "$CRATE_FLAGS" ]; then
                echo "crate_flags=$CRATE_FLAGS" >> "$GITHUB_OUTPUT"
                echo "skip_bench=false" >> "$GITHUB_OUTPUT"
                echo "Benchmarking changed crates:$CRATE_LIST"
              else
                echo "No benchmark-relevant crates changed, skipping"
                echo "crate_flags=" >> "$GITHUB_OUTPUT"
                echo "skip_bench=true" >> "$GITHUB_OUTPUT"
              fi
            fi

            # No bench filters for scheduled runs
            echo "bench_flags=" >> "$GITHUB_OUTPUT"

          # ─────────────────────────────────────────────────────────
          # MANUAL RUNS: Use user-provided inputs (no change detection)
          # ─────────────────────────────────────────────────────────
          else
            echo "Manual run - using user-provided scope"
            echo "skip_bench=false" >> "$GITHUB_OUTPUT"

            # Build crate flags from user input
            if [ -n "$CRATES_INPUT" ]; then
              CRATE_FLAGS=""
              IFS=',' read -ra CRATES <<< "$CRATES_INPUT"
              for crate in "${CRATES[@]}"; do
                crate=$(echo "$crate" | xargs)
                CRATE_FLAGS="$CRATE_FLAGS -p $crate"
              done
              echo "crate_flags=$CRATE_FLAGS" >> "$GITHUB_OUTPUT"
              echo "Running benchmarks for crates: $CRATES_INPUT"
            else
              echo "crate_flags=--workspace" >> "$GITHUB_OUTPUT"
              echo "Running benchmarks for all workspace crates"
            fi

            # Build benchmark binary filter flags from user input
            if [ -n "$BENCHES_INPUT" ]; then
              BENCH_FLAGS=""
              IFS=',' read -ra BENCHES <<< "$BENCHES_INPUT"
              for bench in "${BENCHES[@]}"; do
                bench=$(echo "$bench" | xargs)
                BENCH_FLAGS="$BENCH_FLAGS --bench $bench"
              done
              echo "bench_flags=$BENCH_FLAGS" >> "$GITHUB_OUTPUT"
              echo "Filtering benchmark binaries: $BENCHES_INPUT"
            else
              echo "bench_flags=" >> "$GITHUB_OUTPUT"
              echo "Running all benchmark binaries"
            fi
          fi
        env:
          GITHUB_EVENT_INPUTS_CRATES: ${{ github.event.inputs.crates }}
          GITHUB_EVENT_INPUTS_SPECIFIC_BENCHES: ${{ github.event.inputs.specific_benches }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}

      - name: Skip Notice (No Changes Detected)
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench == 'true'
        shell: bash
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "SKIPPING BENCHMARKS - No Changes Detected"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "This is a scheduled run and no benchmark-relevant crates"
          echo "have changed in the last ~2 weeks."
          echo ""
          echo "To run benchmarks anyway, use the manual trigger."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Clean Old Benchmark Data
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true'
        shell: bash
        run: |
          echo "Cleaning Old Benchmark Data"
          if [ -d "target/criterion" ]; then
            echo "Removing target/criterion/ to ensure clean results"
            rm -rf target/criterion
          else
            echo "No existing criterion data to clean"
          fi

      - name: Build Benchmarks (no-run)
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true'
        shell: bash
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Building Criterion Benchmarks"
          echo "Platform: ${{ matrix.target.name }}"
          echo "RUSTFLAGS: -C target-cpu=native"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          # shellcheck disable=SC2086
          cargo bench --profile bench ${STEPS_SCOPE_OUTPUTS_CRATE_FLAGS} ${STEPS_SCOPE_OUTPUTS_BENCH_FLAGS} --no-run
        env:
          RUSTFLAGS: "-C target-cpu=native"
          STEPS_SCOPE_OUTPUTS_CRATE_FLAGS: ${{ steps.scope.outputs.crate_flags }}
          STEPS_SCOPE_OUTPUTS_BENCH_FLAGS: ${{ steps.scope.outputs.bench_flags }}

      - name: Run Criterion Benchmarks
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true'
        shell: bash
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Running Criterion Benchmarks"
          echo "RUSTFLAGS: -C target-cpu=native"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          mkdir -p benchmark-results
          # shellcheck disable=SC2086
          cargo bench --profile bench ${STEPS_SCOPE_OUTPUTS_CRATE_FLAGS} ${STEPS_SCOPE_OUTPUTS_BENCH_FLAGS} 2>&1 | tee benchmark-results/benchmark-output.txt

        env:
          RUSTFLAGS: "-C target-cpu=native"
          STEPS_SCOPE_OUTPUTS_CRATE_FLAGS: ${{ steps.scope.outputs.crate_flags }}
          STEPS_SCOPE_OUTPUTS_BENCH_FLAGS: ${{ steps.scope.outputs.bench_flags }}

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # Upload Results
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      - name: Generate Benchmark Summary
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true' && always()
        continue-on-error: true
        shell: bash
        run: |
          SUMMARY_FILE="target/criterion/BENCHMARK_SUMMARY.md"
          mkdir -p target/criterion
          {
            echo "# rscrypto Benchmark Report"
            echo ""
            echo "## Run Information"
            echo "- **Platform**: ${{ matrix.target.name }}"
            echo "- **Runner**: ${{ matrix.target.runner }}"
            echo "- **Mode**: $RSCRYPTO_BENCH_MODE"
            echo "- **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            echo "- **Commit**: ${{ github.sha }}"
            echo ""
            echo "## Artifacts"
            echo "- **benchmark-results-${{ matrix.target.platform-id }}**: Console output"
            echo "- **criterion-html-${{ matrix.target.platform-id }}**: Interactive HTML reports"
          } | tee "$SUMMARY_FILE"

      - name: Upload Benchmark Results (Console Output)
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true' && always()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: benchmark-results-${{ matrix.target.platform-id }}
          path: benchmark-results/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 6

      - name: Upload Criterion HTML Report
        if: steps.should-run.outputs.enabled == 'true' && steps.scope.outputs.skip_bench != 'true' && always()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: criterion-html-${{ matrix.target.platform-id }}
          path: target/criterion/
          retention-days: 90
          if-no-files-found: ignore
          compression-level: 6

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # CRC64 Fast Tuning (Manual Only)
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Runs the lightweight `crc64-tune` binary on the selected platforms and
  # uploads the output logs as artifacts. This avoids running full Criterion
  # benchmarks when you only want dispatch threshold/stream recommendations.
  crc64-tune:
    name: CRC64 Tune (${{ matrix.target.name }})
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.run_crc64_tune == 'true'
    runs-on: ${{ matrix.target.runner }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        target:
          - name: x86_64-unknown-linux-gnu
            runner: namespace-profile-rscrypto-linux-x86
            platform-id: linux-x64

          - name: aarch64-unknown-linux-gnu
            runner: namespace-profile-rscrypto-linux-arm64
            platform-id: linux-arm64

          - name: x86_64-pc-windows-msvc
            runner: windows-latest
            platform-id: windows-x64

    steps:
      - name: Check Platform Selection
        id: should-run
        shell: bash
        run: |
          PLATFORM="${{ matrix.target.platform-id }}"

          case "$PLATFORM" in
            "linux-x64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_LINUX_X64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Linux x86-64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Linux x86-64 disabled - skipping"
              fi
              ;;
            "linux-arm64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_LINUX_ARM64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Linux ARM64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Linux ARM64 disabled - skipping"
              fi
              ;;
            "windows-x64")
              if [ "${GITHUB_EVENT_INPUTS_RUN_WINDOWS_X64}" == "true" ]; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "Windows x86-64 enabled by manual trigger"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "Windows x86-64 disabled - skipping"
              fi
              ;;
            *)
              echo "enabled=false" >> "$GITHUB_OUTPUT"
              echo "Unknown platform - skipping"
              ;;
          esac
        env:
          GITHUB_EVENT_INPUTS_RUN_LINUX_X64: ${{ github.event.inputs.run_linux_x64 }}
          GITHUB_EVENT_INPUTS_RUN_LINUX_ARM64: ${{ github.event.inputs.run_linux_arm64 }}
          GITHUB_EVENT_INPUTS_RUN_WINDOWS_X64: ${{ github.event.inputs.run_windows_x64 }}

      - name: Checkout
        if: steps.should-run.outputs.enabled == 'true'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Read Toolchain Version
        if: steps.should-run.outputs.enabled == 'true'
        id: toolchain
        shell: bash
        run: |
          TOOLCHAIN=$(awk -F'"' '/^channel/ {print $2}' rust-toolchain.toml)
          echo "version=$TOOLCHAIN" >> "$GITHUB_OUTPUT"

      - name: Install Rust Toolchain
        if: steps.should-run.outputs.enabled == 'true'
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # master
        with:
          toolchain: ${{ steps.toolchain.outputs.version }}

      - name: Setup Namespace Cache (Linux - instant NVMe cache)
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Linux'
        uses: namespacelabs/nscloud-cache-action@446d8f390563cd54ca27e8de5bdb816f63c0b706 # v1.2.21
        with:
          cache: rust

      - name: Compute Cache Key
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Windows'
        id: cache
        shell: bash
        run: |
          OS=$(echo "${{ runner.os }}" | tr '[:upper:]' '[:lower:]')
          ARCH=$(echo "${{ runner.arch }}" | tr '[:upper:]' '[:lower:]')
          echo "key=tune-${OS}-${ARCH}" >> "$GITHUB_OUTPUT"

      - name: Setup Rust Cache (Windows)
        if: steps.should-run.outputs.enabled == 'true' && runner.os == 'Windows'
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2.8.2
        with:
          shared-key: "rscrypto-tune-v1"
          key: ${{ steps.cache.outputs.key }}
          cache-on-failure: true

      - name: Install Tools
        if: steps.should-run.outputs.enabled == 'true'
        uses: taiki-e/install-action@de7896b7cd1c7d181266425abbe571b5a8c757bc # v2.65.3
        with:
          tool: just

      - name: Run crc64-tune
        if: steps.should-run.outputs.enabled == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p tune-results

          ARGS=()
          if [[ "${CRC64_TUNE_QUICK}" == "true" ]]; then
            ARGS+=(--quick)
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Running crc64-tune"
          echo "Platform: ${{ matrix.target.name }}"
          echo "RUSTFLAGS: -C target-cpu=native"
          echo "Args: ${ARGS[*]:-(none)}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          RUSTFLAGS='-C target-cpu=native' cargo run -p checksum --release --bin crc64-tune -- "${ARGS[@]}" 2>&1 | tee tune-results/crc64-tune.txt

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## crc64-tune (${{ matrix.target.platform-id }})" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          grep '^export RSCRYPTO_CRC64_' tune-results/crc64-tune.txt >> "$GITHUB_STEP_SUMMARY" || true
          echo '```' >> "$GITHUB_STEP_SUMMARY"
        env:
          CRC64_TUNE_QUICK: ${{ github.event.inputs.crc64_tune_quick }}

      - name: Upload crc64-tune Results
        if: steps.should-run.outputs.enabled == 'true' && always()
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: crc64-tune-${{ matrix.target.platform-id }}
          path: tune-results/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 6

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # CRC64 Tuning Discovery (Manual Only)
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Runs the full CRC64 tuning matrix to discover optimal thresholds and stream
  # counts for each microarchitecture. Results guide tune.rs preset updates.
  #
  # Kernels tested:
  # - x86_64: PCLMULQDQ (1-8 way), VPCLMULQDQ/AVX-512 (1-8 way)
  # - aarch64: PMULL (1-3 way), PMULL+EOR3/SHA3 (1-3 way), SVE2-PMULL (1-3 way)
  #
  # Output: tune-results/analysis.json with recommended parallel_streams values
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  tune-discovery:
    name: CRC64 Tune Discovery (${{ matrix.target.name }})
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.run_tune_discovery == 'true'
    runs-on: ${{ matrix.target.runner }}
    timeout-minutes: 240
    strategy:
      fail-fast: false
      matrix:
        target:
          # ═══════════════════════════════════════════════════════════════════
          # x86_64 Targets
          # ═══════════════════════════════════════════════════════════════════

          # AMD Zen4/5 - AVX-512 + VPCLMULQDQ, 6-8 wide dispatch
          # Tests: pclmul (1/2/4/7/8-way), vpclmul (1/2/4/7/8-way)
          - name: x86_64 (AMD Zen4/5)
            runner: namespace-profile-rscrypto-linux-x86
            platform-id: linux-x64-zen
            tune-preset: ZEN4

          # Intel Sapphire Rapids - AVX-512 + VPCLMULQDQ
          # Tests: pclmul (1/2/4/7/8-way), vpclmul (1/2/4/7/8-way)
          # Note: Uses same runner, CPU detection determines actual chip
          # - name: x86_64 (Intel SPR)
          #   runner: [self-hosted, linux, x64, intel-spr]
          #   platform-id: linux-x64-spr
          #   tune-preset: INTEL_SPR

          # ═══════════════════════════════════════════════════════════════════
          # aarch64 Targets - Linux
          # ═══════════════════════════════════════════════════════════════════

          # AWS Graviton3 - PMULL + SVE2 + SHA3 (EOR3), Neoverse V1
          # Tests: pmull (1/2/3-way), pmull-eor3 (1/2/3-way), sve2-pmull (1/2/3-way)
          - name: aarch64 (AWS Graviton3)
            runner: namespace-profile-rscrypto-linux-arm64
            platform-id: linux-arm64-graviton3
            tune-preset: GRAVITON3

          # ═══════════════════════════════════════════════════════════════════
          # aarch64 Targets - macOS (Apple Silicon)
          # ═══════════════════════════════════════════════════════════════════
          # NOTE: macOS tuning is done locally via `just tune-crc64` to avoid
          # CI runner variability. Results are committed to tuned_defaults.rs.

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Read Toolchain Version
        id: toolchain
        shell: bash
        run: |
          TOOLCHAIN=$(awk -F'"' '/^channel/ {print $2}' rust-toolchain.toml)
          echo "version=$TOOLCHAIN" >> "$GITHUB_OUTPUT"

      - name: Install Rust Toolchain
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # master
        with:
          toolchain: ${{ steps.toolchain.outputs.version }}

      - name: Setup Namespace Cache (Linux)
        if: runner.os == 'Linux'
        uses: namespacelabs/nscloud-cache-action@446d8f390563cd54ca27e8de5bdb816f63c0b706 # v1.2.21
        with:
          cache: rust

      - name: Setup Rust Cache (Windows/macOS)
        if: runner.os == 'Windows' || runner.os == 'macOS'
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2.8.2
        with:
          shared-key: "rscrypto-tune-v1"
          cache-on-failure: true

      - name: Install Benchmarking Tools
        uses: taiki-e/install-action@de7896b7cd1c7d181266425abbe571b5a8c757bc # v2.65.3
        with:
          tool: just

      - name: Detect CPU Features
        id: cpu
        shell: bash
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "CPU Detection"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          CPU_MODEL="unknown"
          FEATURES=""

          # Linux detection
          if [[ -f /proc/cpuinfo ]]; then
            CPU_MODEL=$(grep -m1 "model name" /proc/cpuinfo | cut -d: -f2 | xargs || echo "")
            if [[ -z "$CPU_MODEL" ]]; then
              # ARM: use implementer + part
              IMPL=$(grep -m1 "CPU implementer" /proc/cpuinfo | cut -d: -f2 | xargs || echo "")
              PART=$(grep -m1 "CPU part" /proc/cpuinfo | cut -d: -f2 | xargs || echo "")
              [[ -n "$IMPL" && -n "$PART" ]] && CPU_MODEL="ARM impl=$IMPL part=$PART"
            fi

            # x86_64 features
            grep -q "pclmulqdq" /proc/cpuinfo 2>/dev/null && FEATURES="$FEATURES pclmul"
            grep -q "avx512f" /proc/cpuinfo 2>/dev/null && FEATURES="$FEATURES vpclmul vpternlogd"
            # aarch64 features
            grep -q "aes" /proc/cpuinfo 2>/dev/null && FEATURES="$FEATURES pmull"
            grep -q "sha3" /proc/cpuinfo 2>/dev/null && FEATURES="$FEATURES pmull-eor3"
            grep -q "sve2" /proc/cpuinfo 2>/dev/null && FEATURES="$FEATURES sve2-pmull"
          fi

          # macOS detection (Apple Silicon)
          if command -v sysctl &>/dev/null; then
            if [[ -z "$CPU_MODEL" || "$CPU_MODEL" == "unknown" ]]; then
              CPU_MODEL=$(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "")
            fi
            # Apple Silicon always has AES/PMULL
            sysctl -n hw.optional.arm.FEAT_AES 2>/dev/null | grep -q "1" && FEATURES="$FEATURES pmull"
            # SHA3 provides EOR3
            sysctl -n hw.optional.arm.FEAT_SHA3 2>/dev/null | grep -q "1" && FEATURES="$FEATURES pmull-eor3"
          fi

          [[ -z "$CPU_MODEL" ]] && CPU_MODEL="$(uname -m) CPU"

          echo "CPU Model: $CPU_MODEL"
          echo "cpu_model=$CPU_MODEL" >> "$GITHUB_OUTPUT"
          echo "Detected features:$FEATURES"
          echo "features=$FEATURES" >> "$GITHUB_OUTPUT"

      - name: Run CRC64 Tuning Discovery
        shell: bash
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "CRC64 Tuning"
          echo "Platform: ${{ matrix.target.name }}"
          echo "Tune Preset: ${{ matrix.target.tune-preset }}"
          echo "CPU: ${{ steps.cpu.outputs.cpu_model }}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          mkdir -p tune-results
          RUSTFLAGS='-C target-cpu=native' bash scripts/bench/crc64-tune.sh --quick 2>&1 | tee tune-results/tune-output.txt
        env:
          RUSTFLAGS: "-C target-cpu=native"

      - name: Upload Tuning Results
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: tune-discovery-${{ matrix.target.platform-id }}
          path: |
            tune-results/
          retention-days: 90
          if-no-files-found: warn

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Tuning Summary (Aggregates all platform results)
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  tune-summary:
    name: Tuning Summary
    needs: [tune-discovery]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.run_tune_discovery == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download All Tuning Artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: tune-discovery-*
          path: all-results
          merge-multiple: false

      - name: Generate Consolidated Report
        shell: bash
        run: |
          echo "╔══════════════════════════════════════════════════════════════════════════╗"
          echo "║                   CRC64 TUNING - CONSOLIDATED REPORT                   ║"
          echo "╚══════════════════════════════════════════════════════════════════════════╝"
          echo ""
          echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "Commit: ${{ github.sha }}"
          echo ""

          # Process each platform's results
          for dir in all-results/tune-discovery-*/; do
            if [[ -d "$dir" ]]; then
              PLATFORM=$(basename "$dir" | sed 's/tune-discovery-//')
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "Platform: $PLATFORM"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

              # Show platform info
              if [[ -f "$dir/tune-results/platform.json" ]]; then
                echo "CPU: $(cat "$dir/tune-results/platform.json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('cpu_name','unknown'))" 2>/dev/null || echo "unknown")"
                echo "Features: $(cat "$dir/tune-results/platform.json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('features',''))" 2>/dev/null || echo "")"
              fi

              if [[ -f "$dir/tune-results/tune-output.txt" ]]; then
                echo ""
                echo "crc64-tune output:"
                tail -n 200 "$dir/tune-results/tune-output.txt" || true
              fi
              echo ""
            fi
          done

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Update tune presets as needed"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "See individual platform artifacts for raw output."

      - name: Upload Consolidated Report
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: tune-consolidated-report
          path: all-results/
          retention-days: 90
          if-no-files-found: warn

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Regression Detection (Manual Only)
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # Compares current benchmark results against a baseline using critcmp.
  # Useful for detecting performance regressions before releases.
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  regression-check:
    name: Regression Check
    needs: [benchmark]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.regression_baseline != '' && github.event.inputs.tune_only != 'true'
    runs-on: namespace-profile-rscrypto-linux-x86
    timeout-minutes: 60
    steps:
      - name: Checkout Current
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          path: current

      - name: Checkout Baseline
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: ${{ github.event.inputs.regression_baseline }}
          path: baseline

      - name: Read Toolchain Version
        id: toolchain
        shell: bash
        run: |
          TOOLCHAIN=$(awk -F'"' '/^channel/ {print $2}' current/rust-toolchain.toml)
          echo "version=$TOOLCHAIN" >> "$GITHUB_OUTPUT"

      - name: Install Rust Toolchain
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # master
        with:
          toolchain: ${{ steps.toolchain.outputs.version }}

      - name: Setup Namespace Cache
        uses: namespacelabs/nscloud-cache-action@446d8f390563cd54ca27e8de5bdb816f63c0b706 # v1.2.21
        with:
          cache: rust

      - name: Install Benchmarking Tools
        uses: taiki-e/install-action@de7896b7cd1c7d181266425abbe571b5a8c757bc # v2.65.3
        with:
          tool: cargo-criterion,critcmp

      - name: Benchmark Baseline
        shell: bash
        working-directory: baseline
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Benchmarking baseline: ${{ github.event.inputs.regression_baseline }}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          cargo bench --workspace -- --noplot --save-baseline baseline
        env:
          RUSTFLAGS: "-C target-cpu=native"

      - name: Benchmark Current
        shell: bash
        working-directory: current
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Benchmarking current: ${{ github.sha }}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          cargo bench --workspace -- --noplot --save-baseline current
        env:
          RUSTFLAGS: "-C target-cpu=native"

      - name: Compare Results
        shell: bash
        working-directory: current
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Regression Analysis"
          echo "Baseline: ${{ github.event.inputs.regression_baseline }}"
          echo "Current:  ${{ github.sha }}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          mkdir -p regression-results
          critcmp baseline current 2>&1 | tee regression-results/comparison.txt

          # Check for significant regressions (>5% slower)
          if grep -E "regressed|slower" regression-results/comparison.txt | grep -v "1\.[0-4][0-9]x"; then
            echo ""
            echo "⚠️  Potential regressions detected (>5% slower)"
            echo "Review the comparison above for affected benchmarks."
          else
            echo ""
            echo "✅ No significant regressions detected"
          fi

      - name: Upload Regression Report
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        with:
          name: regression-report
          path: current/regression-results/
          retention-days: 90
          if-no-files-found: warn
